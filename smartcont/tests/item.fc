
;; Each test function must specify method_id
;; Test functions method_id need to start from 0

;; Each test functions must to be in pairs
;; First funtion expect nothing in arguments
;; But need to return:
;;        function selector - which function to test, e.g. 0 for recv_internal, -1 recv_external, 85143 for seqno, and so on
;;        tuple - stack values needed to be passed to function in tuple
;;        c4 cell - start data of smart contract
;;        c7 tuple / null
;;        gas limit integer / null


;; test properties of an uninitialized nft
[int, tuple, cell, tuple, int] test_non_initialized_item_get_nft_data_data() method_id(0) {
    int function_selector = 102351; ;; get_nft_data

    tuple stack = unsafe_tuple([null()]);

    cell data = begin_cell() ;; initial nft data
        .store_uint(69, 64)  ;; index
        .store_slice(my_address())  ;;  collection address
        .end_cell();         ;;  No owner, no content yet

    return [function_selector, stack, data, get_c7(), null()];
}

;; After test data function
;; We need to define test funtion
;; It will accept:
;;        exit code - exit code of runvm, here you can check errors / not
;;        c4 cell - data of smart contract after runvm invokes
;;        tuple - stack values of smart contract
;;        c5 cell - here you can check all outcoming messages
;;        gas - gas that was used
;; By default test is passed
;; You can use throw_if to fail test

_ test_non_initialized_item_get_nft_data(int exit_code, cell data, tuple stack, cell actions, int gas) method_id(1) {
    throw_if(100, exit_code != 0); ;; test need to be passed

    int init? = second(stack);
    throw_unless(101, init? == 0); ;;  Not initialized
    
    int index = third(stack);
    throw_unless(102, index == 69); ;;  Index

    slice collection_address = fourth(stack);
    throw_unless(103, equal_slices(collection_address, my_address())); ;;  Collection address
}

;; test properties of an initialized nft
[int, tuple, cell, tuple, int] test_initialized_item_get_nft_data_data() method_id(2) {
    int function_selector = 102351; ;; get_nft_data

    tuple stack = unsafe_tuple([null()]);

    cell content = begin_cell()
        .store_uint(420, 64)
        .end_cell();

    cell data = begin_cell() ;; initial nft data
        .store_uint(69, 64) ;; index
        .store_slice(my_address()) ;; collection address
        .store_slice(my_address()) ;; owner address
        .store_ref(content)  ;; content 
        .end_cell();

    return [function_selector, stack, data, get_c7(), null()];
}

_ test_initialized_item_get_nft_data(int exit_code, cell data, tuple stack, cell actions, int gas) method_id(3) {
    throw_if(100, exit_code != 0); ;; test need to be passed

    int init? = second(stack);
    throw_unless(101, init? == -1); ;;  Initialized
    
    int index = third(stack);
    throw_unless(102, index == 69); ;;  Index

    slice collection_address = fourth(stack);
    throw_unless(103, equal_slices(collection_address, my_address())); ;;  Collection address

    slice owner_address = fifth(stack);
    throw_unless(104, equal_slices(owner_address, my_address())); ;;  Owner address

    slice content = sixth(stack).begin_parse();
    slice expected_content = begin_cell()
        .store_uint(420, 64)
        .end_cell()
        .begin_parse();
    throw_unless(105, equal_slices(content, expected_content)); ;; content
}
